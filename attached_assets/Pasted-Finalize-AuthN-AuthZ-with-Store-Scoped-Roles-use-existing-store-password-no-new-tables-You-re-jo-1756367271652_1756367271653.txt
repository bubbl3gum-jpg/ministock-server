Finalize AuthN/AuthZ with Store-Scoped Roles (use existing store_password, no new tables)

You’re joining an existing ERP web app. Do not invent new tables/columns/variables. Reuse everything that already exists, especially the Store’s store_password field.

Guardrails (must follow)

No schema changes. Reuse existing User/Employee, Role, Store models (names may differ—map in code only).

Use Store.store_password. Do not add any other “store credential” field.

Keep the existing hashing/JWT utilities, DI patterns, routers/middleware, and coding style.

No breaking changes to public APIs unless strictly necessary.

Objectives

Login is store-bound and already present

If POST /auth/login already exists, update it to accept (or map to existing names):

username, password, store_id, store_password

Validation order:

Resolve Store by store_id and verify exact match with existing Store.store_password.

Resolve User and verify password with the existing hashing algorithm.

Verify that the user is authorized to access that store_id per existing relationships.

On success, issue tokens (via existing token utility) containing store context and role claims:

{
  "sub": "<user_id>",
  "username": "<display_name>",
  "role": "<role_name>",
  "store_id": "<store_id>",
  "store_name": "<store_name>",
  "perms": ["sales:create","settlement:read", "..."],
  "iat": 0,
  "exp": 0
}


Keep/implement GET /auth/me, POST /auth/refresh (if supported), POST /auth/logout using existing mechanisms.

Role → permission mapping (reuse existing Role objects)

Map current roles to capabilities. Do not rename roles or change DB. If strings differ, map in code.

Admin: full access (all stores, all features).

SPG: only in current store_id: New Sales, Settlements, Transfers, Pricelist, Stock Opname, Discounts.

Supervisor: everything SPG has in current store, plus Store Overview (only that store).

Represent permissions using existing enums/constants/utilities.

Backend authorization middleware/guards

Verify access token using existing JWT/session utility.

Extract user_id, username, role, store_id, perms.

Enforce store scoping by default in service/repository layer: every non-admin read/write must be implicitly filtered by token’s store_id.

Ignore any client-provided store_id for authorization. Use it only for display or store switching.

Return 403 on insufficient permissions with a clear message.

UI gating & identity display

After login:

Topbar shows the logged-in username.

Show a store badge with store_name/store_id.

Sidebar/routes are driven by perms:

SPG: New Sales, Settlements, Transfers, Pricelist, Stock Opname, Discounts.

Supervisor: above + Store Overview (only current store).

Admin: all.

Add route guards to redirect unauthorized users to a friendly “Not allowed” page.

Store switching

Require re-authentication with store_id + store_password (plus the user’s credentials) to switch stores. Issue a fresh token whose store_id reflects the new store. Clear store-scoped caches/state.

Security

Use existing password hashing (bcrypt/argon2) and existing JWT signing keys/algorithms.

Keep current CORS/rate-limit/lockout policies and utilities.

Log all login/logout/store-switch events with existing logging/audit utilities.

Acceptance Criteria

POST /auth/login (or existing login endpoint) accepts username, password, store_id, store_password and validates in the order above.

Tokens include role and store_id; GET /auth/me returns user + store context.

SPG sees only: New Sales, Settlements, Transfers, Pricelist, Stock Opname, Discounts — scoped to current store.

Supervisor: SPG features + Store Overview for current store only.

Admin: full cross-store access.

All non-admin reads/writes are implicitly restricted to token store_id at the service/repo layer.

Unauthorized access → 403; hidden menu items for missing permissions.

Store switching requires re-auth with store_password and issues a new store-scoped token.

No new tables/columns/renames were introduced; only code-level mapping and integration.

Test Scenarios

SPG logs into Store A → can create a sale in A; cannot open Store B overview or data.

Supervisor logs into Store A → can open Store Overview for A; cannot open B.

Admin → can access all stores/features.

Wrong store_password → login fails with clear message.

Token expired/tampered → consistent 401.

Client sends mismatched store_id in payload → server still enforces token’s store_id.